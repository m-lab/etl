// Package tcpip contains code to extract IP and TCP packets from a PCAP file,
// and model the TCP connection state machine.
package tcpip

import (
	"encoding/binary"
	"fmt"
	"log"
	"net"
	"os"
	"time"
	"unsafe"

	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"github.com/m-lab/go/logx"
)

var (
	info         = log.New(os.Stdout, "info: ", log.LstdFlags|log.Lshortfile)
	sparseLogger = log.New(os.Stdout, "sparse: ", log.LstdFlags|log.Lshortfile)
	sparse20     = logx.NewLogEvery(sparseLogger, 50*time.Millisecond)

	ErrNotTCP            = fmt.Errorf("not a TCP packet")
	ErrNoIPLayer         = fmt.Errorf("no IP layer")
	ErrTruncatedIPHeader = fmt.Errorf("truncated IP header")
)

type EthernetHeader struct {
	SrcMAC, DstMAC [6]byte
	etherType      [2]byte // BigEndian
}

func (e *EthernetHeader) EtherType() layers.EthernetType {
	return layers.EthernetType(binary.BigEndian.Uint16(e.etherType[:]))
}

// IPv4Header struct for IPv4 header
type IPv4Header struct {
	VersionIHL   uint8   // Version (4 bits) + Internet header length (4 bits)
	TOS          uint8   // Type of service
	Length       [2]byte // Total length
	Id           [2]byte // Identification
	FlagsFragOff [2]byte // Flags (3 bits) + Fragment offset (13 bits)
	TTL          uint8   // Time to live
	Protocol     uint8   // Protocol of next following bytes
	Checksum     [2]byte // Header checksum
	SrcIP        [4]byte // Source address
	DstIP        [4]byte // Destination address
}

func (h *IPv4Header) PayloadLength() uint16 {
	ihl := h.VersionIHL & 0x0f
	return binary.BigEndian.Uint16(h.Length[:]) - uint16(4*ihl)
}

// IPv6Header struct for IPv6 header
type IPv6Header struct {
	VersionTrafficClassFlowLabel [4]byte // Version (4 bits) + Traffic class (8 bits) + Flow label (20 bits)
	Length                       [2]byte // Payload length
	NextHeader                   uint8   // Protocol of next following bytes
	HopLimit                     uint8   // Hop limit
	SrcIP                        [16]byte
	DstIP                        [16]byte
}

type TCPOption struct {
	Kind uint8
	Len  uint8
	// This byte array may be shorter than 38 bytes, and cause panics if improperly accessed.
	Data [38]byte // Max length of TCP option is 40 bytes
}

// TCPHeader is autogenerated using Copilot.
type TCPHeader struct {
	SrcPort, DstPort [2]byte // Source and destination port
	SeqNum           [4]byte // Sequence number
	AckNum           [4]byte // Acknowledgement number
	DataOffsetFlags  uint8   // DataOffset, and Flags
	Window           [2]byte // Window
	Checksum         [2]byte // Checksum
	Urgent           [2]byte // Urgent pointer
}

type TCPHeaderWrapper struct {
	TCP     *TCPHeader
	Options []*TCPOption
}

func (h *TCPHeader) DataOffset() uint8 {
	return 4 * ((h.DataOffsetFlags & 0xf0) >> 4)
}

func (h *TCPHeader) FIN() bool {
	return (h.DataOffsetFlags & 0x01) != 0
}

func (h *TCPHeader) SYN() bool {
	return (h.DataOffsetFlags & 0x02) != 0
}

func (h *TCPHeader) RST() bool {
	return (h.DataOffsetFlags & 0x04) != 0
}

func (h *TCPHeader) PSH() bool {
	return (h.DataOffsetFlags & 0x08) != 0
}

func (h *TCPHeader) ACK() bool {
	return (h.DataOffsetFlags & 0x10) != 0
}

// Packet struct contains the packet data and metadata.
type Packet struct {
	// If we use a pointer here, for some reason we get zero value timestamps.
	Ci   gopacket.CaptureInfo
	Data []byte
	Eth  *EthernetHeader
	IPv4 *IPv4Header       // Nil unless we're parsing IPv4 packets.
	IPv6 *IPv6Header       // Nil unless we're parsing IPv6 packets.
	TCP  *TCPHeaderWrapper // This takes up a small amount of space for the options.
	Err  error
}

func (p *Packet) GetLayers() error {
	p.Eth = (*EthernetHeader)(unsafe.Pointer(&p.Data[0]))
	switch p.Eth.EtherType() {
	case layers.EthernetTypeIPv4:
		if len(p.Data) < int(14+unsafe.Sizeof(IPv4Header{})) {
			return ErrTruncatedIPHeader
		}
		p.IPv4 = (*IPv4Header)(unsafe.Pointer(&p.Data[14]))
	case layers.EthernetTypeIPv6:
		if len(p.Data) < int(14+unsafe.Sizeof(IPv6Header{})) {
			return ErrTruncatedIPHeader
		}
		p.IPv6 = (*IPv6Header)(unsafe.Pointer(&p.Data[14]))
	default:
		return ErrNoIPLayer
	}
	return nil
}

func (p *Packet) TCPLength() int {
	if p.IPv4 != nil {
		return int(p.IPv4.PayloadLength())
	}
	return int(binary.BigEndian.Uint16(p.IPv6.Length[:]))
}

// GetTCP constructs or retrieves the TCPHeaderWrapper for this packet.
// This requires correctly parsing the IP header to find the correct offset,
// and then parsing the TCP header and creating the options array.
// The result is cached in the Packet's TCP field.
func GetTCP(data []byte) (*TCPHeaderWrapper, error) {
	return nil, ErrNotTCP
}

// FastExtractIPFields extracts a few IP fields from the packet.
func (p *Packet) FastExtractIPFields() (srcIP, dstIP net.IP, TTL uint8, tcpLength uint16, err error) {
	if p.Eth == nil {
		err = p.GetLayers()
		if err != nil {
			return nil, nil, 0, 0, err
		}
	}
	if p.IPv4 != nil {
		srcIP = make([]byte, 4)
		dstIP = make([]byte, 4)
		copy(srcIP, p.IPv4.SrcIP[:])
		copy(dstIP, p.IPv4.DstIP[:])
		TTL = p.IPv4.TTL
		tcpLength = p.IPv4.PayloadLength()
		if p.IPv4.Protocol != uint8(layers.IPProtocolTCP) {
			err = ErrNotTCP
		}
	} else if p.IPv6 != nil {
		srcIP = make([]byte, 16)
		dstIP = make([]byte, 16)
		copy(srcIP, p.IPv6.SrcIP[:])
		copy(dstIP, p.IPv6.DstIP[:])
		TTL = p.IPv6.HopLimit
		tcpLength = binary.BigEndian.Uint16(p.IPv6.Length[:])
		if p.IPv6.NextHeader != uint8(layers.IPProtocolTCP) {
			err = ErrNotTCP
		}
	} else {
		return nil, nil, 0, 0, ErrNoIPLayer
	}
	return
}
